---
layout: post
title:  "생활코딩 자바스크립트"
date:   2017-02-07 21:17:00 +0900
---

프로그래밍은 도구를 만드는 일이기 때문에, 만드는 과정에서 어느 도구와 함께 할지 선택하는 것도 매우 중요한 문제

신경을 써서 계속 개선시키지 않으면 쓰던 도구만 쓸 수 밖에 없다

인지의 한계를 도구를 통해 극복하는 것

좋은 코드를 작성하려는 노력만큼 좋은 도구를 찾는 노력을 게을리 해서는 안 된다

생산성이 좋은 도구들은 도구의 효용이 좋을수록 사용하기 위해서 충분한 리소스를 가지고 접근해야 지치지 않고 익힐 수 있을 것

지식이라는 것이 순서대로 전달되긴 하지만, 꼭 그 순서대로만 익힐 수 있는 것은 전혀 아니다

현재 다루는 내용이 모르는 것과 함께 나오더라도, 일단 학습 목적에만 집중하는 것이 중요하다

(애매한 것에 관대한 사람과 엄격한 사람, 초반에는 관대한 사람(학습량과 속도)이 후반에는 엄격한 사람(원리와 구조 이해)이 유리하기 마련)

프로그래밍을 할 때 매우 중요한 부분은 변할 수 있는 부분과 변하지 않는 부분을 분리시키는 것이다

좋은 주석을 가지고 있는 코드가 좋은 코드이다(주석조차 필요하지 않고 가독성이 높으면 최고의 코드)

주석은 타인 또는 곧 타인이 될 나 자신을 위해 필요하다

에러는 내가 작성하고 있는 시점에 파악하는 것이 최선이다

본질을 파악하면 이해력도 높아지고 암기할 것도 줄어든다

조건문은 컴퓨터를 똑똑하게, 반복문은 컴퓨터를 강력하게-

기능에 대해서 공부할 때는 그냥 공부하는 것이 아니라, 그것이 없었다면 얼마나 불편할지를 생각해보자

처음 그 기능을 마주한 사람은 얼마나 즐거웠을까? 를 생각해보면 재밌게 할 수 있다

복사 붙여넣기는 전자화된 기기의 최대 혜택중 하나인 듯

감수성이 중요합니다

영어나 수학 때문에 프로그래밍을 못 한다는 생각보다는 프로그래밍을 통해 영어와 수학도 잘 할 수 있게 된다고 생각해보자

---

자바스크립트에서는 정수 실수 구분이 큰 의미가 없음, 프로그래머가 지정한 그대로 형식이 결정되기 때문

수학 관련한 것을 할 때는 Math의 메소드를 사용

Math.random(); 의 결과는 0부터 1 사이의 숫자

Math.round(100 * Math.random());



##### 임지호님 댓글

javascript의 데이터형식에는 크게 숫자와 문자가 있다.
숫자는 또 크게 정수와 실수로 나뉘고 숫자끼리는 사칙연산이 가능하다(+,*,/,-)
사칙연산 뿐 아니라 Math같은 함수를 쓰면 제곱, 제곱근, 난수 등 복잡한 계산도 가능하다.
문자는 ""나 ''사이에 기록되어야 한다.
간혹 ''사이에 '를 써야 하는 경우 \' 이와 같은 모습으로 기록을 해주어야 컴퓨터가 문자로서 '를 인지한다.
\를 이스케이프라 한다.
숫자도 ""나 ''사이에 기록되면 문자로 인식된다.
문자들을 결합하면 결합한 문자들이 이어서 나온다.
문자를 여러줄 쓰고 싶으면 \n이라고 쓰면 된다.(Enter와 같은 역할)
문자에서도 .length나 .indexof같은 명령을 쓰면 여러 가지 복잡한 기능을 수행할 수 있다.



#### 임지호님 댓글

변수 : 값을 담는 그릇(값을 유지할 필요가 있을 때)
var로 시작해서 변수 선언.
다른 값을 담을 수도 있다. 그럴 때는 다시 var 쓸 필요 없다.
변수에는 숫자, 문자 등등 어떤 것도 담길 수 있다.
그것들을 사용해서 연산, 결합 등 할 수 있다
변수 2개를 동시에 선언할 때는 var a = 1, b = 2의 형태로 var는 한 번만 쓰고 ,로 연결하면 된다.
변수는 코드의 재활용성을 높이기 위해서 쓴다.
이것은 코딩을 할 때 대단히 중요한 특성이다.

주석처리 된 코드는 브라우저가 그 코드를 무시해버린다.
//(한 줄)와 /* ~ */(여러 줄)의 형태가 있다.
코드에 대한 설명이 필요할 때 주석을 쓰기도 하고
일시적으로 어떤 코드의 동작을 멈출 때 주석을 쓰기도 한다.

; 명령이 끝났다는 것을 명시적으로 표시

비교 연산자 : 좌항, 우항을 비교할 때 쓰는 연산자

대입 연산자(=) : 우항의 값을 좌항에 대입할 때 사용
동등 연산자(==) : 좌항, 우항의 값이 같으면 true, 다르면 false(실질적인 정보의 값을 비교)
일치 연산자(===) : 위와 내용은 같음(데이터 형식까지 엄격하게 비교, 동등보다는 이것을 쓰는 것을 권장)
undefined : 프로그래머가 의도하지 않은 값 없는 상태, null : 의도한 값 없는 상태

조건문은 조건에 따라 실행을 달리 하게 하는 것이다.
if(true) {...} 실행한다. if(false) {...} 실행 안한다.
if(true) {...} else {~~~} true이면 ... 실행하고 false이면 ~~~실행한다.
else if로 조건문을 더 풍성하게 할 수 있다. 수많은 else if 중 true인것만 실행하고 없다면 else 실행한다.
(else는 생략 가능하다)
조건문은 중첩 또한 가능하다.
논리 연산자 
-&&(AND) : 좌항, 우항 모두 true일 때 전체가 true
-||(OR) : 좌항, 우항 중 하나만 true이면 전체가 true
-!(NOT) : true이면 false로, false이면 true로 변환

반복문 : 코드를 반복적으로 실행하게 하는 기술.
while과 for문이 있다.
while(반복조건) {실행코드} 이런 문법적 형태를 띄는데 무한루프에 빠지지 않도록 하는 초기화변수와 변수를 증가시키는 코드, 반복조건 코드가 필요하다.
이것을 한눈에 보기 좋게 표현한 것이 for문이다.
for(var i=0; i<10; i++) {실행코드}의 형태를 띈다. 반복문은 반복문끼리 그리고 조건문과도 중첩이 가능하다.

* i++과 ++i의 차이 : i++은 i를 실행하고 i에 1을 더하고 ++i는 1을 더하고 i를 실행한다.

document.write : 웹페이지에 텍스트를 출력

함수 : 코드의 재사용성을 높이기 위한 기술.
function 이름 (매개변수) {실행코드}의 형태를 가진다.
실행할때는 이름(인자)를 하면 실행코드에서 return값이 출력된다.
반복문과 같이 반복할 수 있다는 특성이 있지만 반복문은 단순반복이고 함수는 입력값에 따라 출력값이 다르게
반복되고 여러군데에서 사용할 수 있다.
코드의 재사용성을 높일 수 있고 유지보수가 용이해지며 가독성 또한 좋아진다.
변수이름 = function(매개변수) {실행코드}의 형태로도 함수를 정의할 수 있고
(function(매개변수) {실행코드})(); 이런식의 형태는 익명함수로 함수를 정의하고 바로 호출해야할 때 사용한다.
함수기능은 반복화의 중요한 부분을 기능으로 만드는 작업
과도한 함수화는 소스 가독성을 느리게 한다는 점을 명심하기
반복문은 그 자리에서 바로 반복을 하게끔 하는 효용이 있는 반면, 함수는 반복적으로 실행되는 로직이 다양한 맥락에서 호출되어야 할 때 아주 유의미하다
사용하는 입장에서는 이름과 그것의 역할과 영향만 알면 사용할 수 있다
즉 함수는 재사용성, 유지보수의 용이, 가독성이라는 프로그래밍이 지향하는 바와 밀접하게 연관되어있다
함수의 함은 상자, 인풋을 넣으면 아웃풋이 나오는 상자의 의미
함수의 입력과 출력에서 출력은 return이 담당하는 역할, 입력은 argument가 담당
또한 입력되는 인자는 argument, argument(함수 호출시)를 받는 자리는 parameter(함수 안)
입력은 여러 개를 동시에 받을 수 있으나, 출력은 오직 한 번만 가능(이 출력은 console.log의 출력과는 다르다)
함수를 선언하고 그것을 ()로 감싸면서 그 안에 ()를 넣어서 바로 호출할 수 있다 = 익명함수
자바스크립트에서는 함수가 차지하는 위상이 매우 높다



배열 : 여러 개의 데이터를 담기 위한 그릇의 역할

- 하나하나의 데이터를 원소라 하고 그것을 식별하는 식별자를 주로 인덱스라 칭한다.(0부터 순서대로 자동매김)


- 배열.length : 배열의 크기 출력
  .push : 배열 끝에 원소 추가
  .concat : 여러개 원소 추가
  .unshift : 배열 처음에 원소 추가
  .splice : 배열 요소의 추출 또는 추가
  .shift : 첫 번째 원소 제거
  .pop : 맨 뒤 원소 제거
  .sort : 정렬(사용자가 정의한 기준으로도 정렬 가능)
  .reverse : 역순정렬





함수가 한 번에 하나만 반환할 수 있는 한계를 극복하기 아주 좋은 방식이 배열이다
배열의 인덱스별 데이터를 모두 기억할 수는 없으므로, 기본적으로 배열에 담겨진 데이터들을 꺼내어 가공할 때 주로 사용하게 된다(인덱스별 데이터를 기억해서 활용해야 할 때는 객체를 사용해야 할 것)
배열은 반복문과 함께 사용되었을 때 진정한 힘이 나온다
배열.length를 사용하여 배열의 원소 개수와 비례한 반복문을 작성할 수 있음
인자, 반환값, 설명, 예제를 참고하여 레퍼런스로부터 학습하자
정렬은 배열을 사용하는 이유 중 하나이고 프로그래밍에서 상당히 중요한 주제이다
언어에서 지원하는 정렬방법을 사용하는 것이 지금은 가장 효과적일 것
sort function을 지정해서 원하는 방법에 따라 정렬할 수 있다



객체 : 연관된 데이터를 담는 그릇. 인덱스를 문자로 사용하는 것이 배열과 다른 점.

- var .... = {'key값' : value값 , ~~~~}의 형태, 빈 객체 만들고 후에 값 지정도 가능
- 객체와 반복문이 만날 때 for(key in 객체) { ...key - key값 or 객체[key] - value값}(배열에서도 사용 가능)
- 객체 안에 객체 또는 함수가 들어갈 수 있음(연관된 데이터, 처리를 그룹핑해서 프로그래밍하는 것을
  객체지향프로그래밍이라 함)
- 함수 안에서 this를 사용하면 함수를 가지고 있는 객체를 가리키는 변수로 사용된다.




배열은 색인이 자동으로 지정되는 것에 반해, 객체는 우리가 원하는 색인(key)을 할 수 있다
다른 언어에서는 연관배열, 맵, 딕셔너리 등이 객체에 해당한다
객체 지향과 연결되는 부분
데이터를 호출할 때 dot notation으로는 문자열 형태를 받을 수 없으므로 그럴 때는 []를 사용할 것
문자열 또는 변수로 접근해야 한다면 []를 써야만 한다, 아닌 경우에는 dot notation 사용
배열은 순서가 있으나, 객체는 그렇지 않다(오직 key를 통해서 접근)
for in문 활용
값으로서의 함수를 value로 가지고 있을 수 있고, 그 함수의 this는 그 함수를 가지고 있는 객체를 가리킴
연관되어있는 데이터와 함수를 객체로 그룹핑해놓는 것을 객체지향 프로그래밍이라고 함

```javascript
var grades = {
  list: {egoing: 10, k8805: 8, sorialgi: 80},
  show: function() {
    for (let name in this.list) {
      console.log(name, this.list.name);
    }
    console.log(this.list);
  }
}

grades.show();
```





모듈 : 로직들을 부품화한 것. 부품화하는 과정을 모듈화라 함.

- 모듈화하면 유지보수, 재사용성, 비용절약 등 많은 측면에서 이익이 생김.
- 호스트 환경(웹브라우저, node.js, 구글앱스스크립트 등)마다 모듈화하는 방식이 다름(자바스크립트 내부에서 모듈화하는 기능은 없음)
- 웹에서는 <head>태그에 자바스크립트파일을 로드하는 방식을 사용
- 라이브러리도 모듈과 비슷한 느낌이지만 모듈은 부품 하나라면 라이브러리는 방대한 코드의 집합의 느낌



프로그램은 작고 단순한 것에서 크고 복잡한 것으로 진화하는데, 이때 코드의 재활용성과 유지보수의 편이성을 위해 모듈화가 꼭 필요하다
재사용할 수 있는 단위로 구획화시킨 것이 모듈, 그것을 만드는 것이 모듈화
함수보다 더 큰 개념이 모듈(재사용성을 높이기 위한 관점에선 동일)
필요한 함수, 변수, 로직을 묶어 모듈화
필요한 코드와 그렇지 않은 코드를 분리해서 생각해보자
이 파일에서 중요하지 않은 부분을 모듈화해서 분리해내어, 이 파일의 가독성을 획기적으로 높일 수 있다
<script src="greeting.js"></script> 라고 선언하면 greeting.js의 파일 내용들이 >< 사이에 적힌 효과
Node.js에서는 require를 통해 module을 import해온다 (JS 호스트 환경마다 다르다는 예시)라이브러리는 모듈과 비슷한 개념이다. 모듈이 프로그램을 구성하는 작은 부품으로서의 로직을 의미한다면 라이브러리는 자주 사용되는 로직을 재사용하기 편리하도록 잘 정리한 일련의 코드들의 집합을 의미한다고 할 수 있다.
내가 구현하려는 기능이 내 서비스의 핵심에 해당하지 않는다면, 이미 구현되어있는 라이브러리가 있는지 찾아볼 것, 단지 사용하려는 목적이라면 이미 있는 라이브러리보다 품질이 좋기는 어렵다웹과 관련한 어느 JS 라이브러리라도 JS와 브라우저가 제공하지 않는 기능을 할 수는 없다
라이브러리란 어떤 특정 목적을 설정해놓은 로직들의 집합
jQuery를 사용하려면 모듈을 import를 해와야 함, 제공하는 기능들은 Documentaion Doc에 적혀있을 것
라이브러리를 사용하려면 import 방법과 Documentation 숙지하는 것이 핵심
환경을 제어하기 위해선 그 환경이 제공해주는 API가 무엇이 있고, 어떤 특성과 사용법인가를 알아내야 함
자신이 필요한 것을 스스로 찾을 수 있는 것이 주체적인 프로그래밍의 시작점일 것



Interface : 주체와 주체가 만나는 접점

- UI : 사용자와 시스템이 만나는 접점
- API : 시스템과 프로그래머가 만나는 접점(개발자는 시스템, 프로그래밍언어의 API를 통해 프로그램을 제어)
- 프로그래밍을 공부하기 위한 자료 : 튜토리얼(기본적인 조작 안내서(문법)), 레퍼런스(명령어 사전)
- 자바스크립트는 자바스크립트가 기본적으로 제공하는 API와 그것이 구동되는 호스트환경이 제공하는 API가 
  다르다.

튜토리얼을 통해 해당 환경이 어떤 API를 제공해주는지 사전기반을 쌓고 (문법), 레퍼런스를 통해 자세히 익힐 수 있음 (사전)
자바스크립트 API는 자바스크립트 자체의 API와 호스트 환경의 API로 구분된다
프로그래밍이란 API + 커뮤니티나 검색을 통해 문제 상황에 대한 답을 찾아가는 과정일 것



전역변수/지역변수 : 함수 바깥에서 선언된 변수(전역적으로 영향을 미침)/함수 내에서 선언된 변수(함수 내에서만
영향을 미침)

- 전역변수는 거의 쓰이지 않음(프로그램이 커질수록 변수의 이름이 서로 헷갈릴 수 있기 때문. 이런 개념도 그러
  한 문제때문에 고안된 것)
- 함수 밖에서 var를 쓰면 전역변수, 함수 안에서 var를 쓰면 지역변수
- 전역변수를 딱 하나만 쓰려면 전역변수 하나를 객체로 만들고 그 소속 아래 나머지 변수를 선언한다.
- 전역변수를 쓰지 않으려면 만든 로직을 익명함수화한다(모듈화의 기초)
- 자바스크립트의 지역변수는 {}가 아니라 함수!에서만 유효하다.
- 자바스크립트는 정적 유효범위를 채택한다(함수 호출시점이 아니라 선언 시점을 기준으로 한다)


앞선 내용들은 어느 프로그래밍 언어든 제공할 개념들이다
갖게 될 것보다 갖고 있는 것을 더 중요하게 생각하길 바란다
자바스크립트에서의 함수는 모듈화의 근간이다
같은 함수 내에 변수명이 없을 경우, 전역 변수 중에서 해당 변수명에 해당하는 변수가 있는지 찾는다
블록이 아닌 함수 단위의 스코프를 제공한다
왜 전역변수를 써야 하는지 구체적으로 인지하고 있는 상황이 아니라면 늘 지역변수를 사용할 것
수많은 함수와 변수가 만들어질 수 있는데 그것들이 결합되는 과정에서 같은 변수명을 사용해서 겹치게 되면 이름의 충돌으로 인해 예상과 다르게 동작하는 문제가 생길테니 최대한 지역변수를 사용하는 것이 좋다
파일 -> 디렉토리 와 같이 문제를 해결하기 위해 나온 결과물이 스코프
프로그래밍 개념들이 그냥 하늘에서 떨어진 것이 아니라 그 당시의 문제들을 해결하기 위한 고민의 결과라고 생각하고 공부해볼 것
null은 프로그래머가 현재 값을 지정하지 않았다는 것을 명시적으로 선언한 것
같은 이름의 지역변수와 전역변수가 있을 경우 지역변수가 우선한다
불가피하게 전역변수를 사용해야 한다면, 객체에 담아서 사용하자
함수가 선언된 시점에서의 유효범위를 가짐, 이것을 정적 유효범위(lexical scoping)라고 함
사용될 때가 아닌, 정의될 때의 스코프를 가진다
반대를 동적 유효범위라고 함
프로그래밍이 커지면서, 이해되지 않는 문제들이 생기면 스코프 때문일 가능성이 있다

```
자바스크립트에서 함수를 선언할때
function statement 방식과 function expression 방식이 있는데 
(Function() 생성자 함수를 사용한 방법도 있습니다)

function statement 방식은 흔히 함수를 선언하는

function a()
{
함수식;
}

방식이고

function expression 방식은 변수를 선언해서 함수를 대입하는 방식입니다.

var a = function(){};

이런씩으로 생성이 되는데 여기서 또 함수의 접근 범위가 달라집니다.


a();

function a()
{
alert(1);
}

이런 식으로 함수 선언보다 앞에서 함수를 호출하면 호출이 됩니다.

하지만

a();

var a = function()
{
alert(1);
}
이런 식으로 function expression 방식으로 함수를 선언하게 되면 
함수 호출을 막아줍니다.
그래서 이런 식으로 함수를 선언하라고 권고 하고 있고요

이런 현상은 호이스팅이라고 한다 (선언과 할당의 분리)
```

```javascript
var vscope = 'global';
function fscope() {
  var vscope = 'local'; // 지역변수로 vscope가 생성됨
  vscope = 'local'; // 위에서 생성된 지역변수에 값을 할당하게 됨
}
fscope();
alert(vscope);

// 단 하나의 전역변수도 사용하고 싶지 않을 때
(function() {
  var myAPP = {};
  myAPP.calculator = {
    left: null,
    right: null
  };
  myAPP.coordinate = {
    left: null,
    right: null
  };
  
  myAPP.calculator.left = 10;
  myAPP.calculator.right = 20;
  function sum() {
    return myAPP.calculator.left + myAPP.calculator.right;
  }
}())

var i = 5;

function a() {
  var i = 10;
  b();
}

function b() {
  document.write(i);
}

a();
```

값으로서의 함수 : 자바스크립트에서 함수는 값으로도 쓰일 수 있다(변수에 담기, 객체 안에 저장하기, 다른 함수의 인자로 사용하기, 함수의 리턴값으로 사용하기, 배열의 값으로 사용하기 등) -> first-class-object,citizen이라함
*객체 안에서 key는 변수 역할, 속성이라고도 부르고 value에 함수가 담긴다면 이는 메소드라 부른다
- 콜백함수 : 함수가 다른 함수의 인자로 사용됨으로써 그 함수의 내용을 완전히 바꿀 수 있는 것.
- 비동기처리 : 시간이 오래 걸리는 작업을 나중에 처리해서 일련의 작업을 순서대로 처리하지 않음으로써 사용의 편의성을 높이는 기법.(일반 환경에서는 보이지 않고 서버 환경에서 구동된다) - 대표적으로 Ajax라는 기법이있음


값으로서의 함수와 콜백
함수도 객체, 함수 역시 일종의 값, 함수 자체가 값이 될 수 있다
함수는 값이기에 객체 안에 저장될 수 있다, 객체의 key는 곧 변수와 같은 역할, 이것을 속성이자 프로퍼티라고 함, 이렇게 객체의 속성 값으로 담겨진 함수를 메소드라고 부른다
다른 함수의 인자로 전달될 수 있음, 함수는 함수의 리턴 값으로도 사용할 수 있다
배열의 값으로도 사용할 수 있음, 뒤에 (인자) 를 전달해주면 호출됨
변수, 매개변수, 리턴값으로 활용될 수 있는 데이터를 프로그래밍에서는 일급 객체라고 한다
값으로 사용될 수 있는 특성을 이용하면 함수의 인자로 함수를 전달할 수 있다
값으로 전달된 함수는 호출될 수 있기 때문에 이를 이용하면 함수의 동작을 달리 할 수 있다
numbers.sort(); 가 있을 때 . 앞의 것을 객체라고 함
객체에 속해있는 함수는 메소드
언어에서 기본적으로 정의되어있는 것들을 내장 객체, 내장 메소드, 빌트인 객체 빌트인 메소드라고 한다, 그렇지 않은 것들은 사용자 정의 객체, 사용자 정의 함수라고 한다
sort는 기본적으로 문자열로 정렬하고 윈도우 이름 순서도 이렇다
반환값은 배열, 자기 자신에 대한 레퍼런스값
값으로서의 함수의 특징을 활용하여, 다른 함수의 인자값으로 함수를 전달하는 것을 통해 동작 방식을 바꿀 수 있다, 이때 넘겨주는 함수를 콜백함수라고 함
비동기 방식의 예시로는 To Do List를 떠올리면 된다
Ajax 비동기 자바스크립트 통신방식이 비동기적 처리의 예시, 웹페이지가 변경되지 않고 일부분만 변경할 수 있게 해줌, 웹이 문서에서 벗어나서 동작들을 할 수 있는 애플리케이션으로 발전되는 중요한 계기가 됨
이것을 구현하려고 할 때, 브라우저별로 차이점이 발생하는데, jQuery를 사용하면 쉽게 할 수 있음
정보를 가져오기 위한 Ajax라는 과정 자체는 모두 같지만, 정보를 가져온 다음에 어떤 로직을 작동해야 할지는 콜백함수가 결정하는 것
고난도 테크닉이자, 유지보수를 쉽게 만드는데 중요한 개념이다

```javascript
function cal(mode) {
	var funcs = {
		plus: function(left, right) { return left + right },
		minus: function(left, right) { return left - right }
    };
	return funcs[mode];
}

alert(cal("plus")(2, 1));
```

클로저

클로저 : 내부함수가 외부함수의 맥락에서 접근할 수 있는 것.(함수 안에서만 사용하는 함수를 만들 때 유용)
- 내부함수 : 함수 안에 함수가 선언되 있는 것
- 외부함수 : 내부함수 바깥에 선언된 함수
- 내부함수는 외부함수의 지역변수에 접근할 수 있다.
- 외부함수가 소멸되도 내부함수는 외부함수의 지역변수에 접근할수 있다.
- 프라이빗변수 : 정보를 아무나 수정하는 것을 방지하는 기법(이 기법에 클로저를 사용)

내부함수의 외부함수의 지역변수에 접근할 수 있다
외부함수가 종료된 이후에도 내부함수는 외부함수에 접근할 수 있다
자신들이 실행된 그 시점에서의 외부함수의 지역변수에 접근할 수 있고 그것은 유지되고 있다
그리고 자신이 가지고 있는 맥락의 외부함수 지역변수를 변경해도, 다른 클로저에는 영향을 미치지 않는다
클로저는 자바스크립트가 Private Variable를 사용하게 되면 즉 어떤 데이터에 접근할 수 있는 경로가 제한되면, 그 데이터를 다른 이들이 다른 맥락에서 사용하더라도 영향을 받지 않게 할 수 있고, 그 변수를 수정할 때도 Validation할 수 있고, 읽는 경로도 제한되기 때문에 훨씬 안전하게 저장될 수 있다, Closure는 자바스크립트가 Private한 변수를 만들게 하는데 매우 좋은 매커니즘이다, 클로저를 통해 맥락을 만들어낼 수 있다는 점이 핵심
지역변수에 매개변수도 당연히 포함된다

클로저는 독립적으로 클로저 안에 정의된 함수를 기억하기 위해서 사용합니다.
주의할점은 클로저가 필요하지 않은 작업인데도 함수안에 함수를 만듬으로써
스크립트 처리 속도와 메모리 사용량 모두에 부담을 주므로 유의하여야 합니다.
실용적인 클로저란 "하나의 객체에서 여러가지 이벤트에 반응하는 콜백을 사용하는 상황" 에 매우 적합하다.

```javascript
function factory_movie(title) {
  return {
    get_title: function() {
      return title;
    },
    set_title: function(_title) {
      if (typeof _title === "string") {
        title = _title;
      } else {
        alert("제목은 문자열이어야 합니다.");
      }
    }
  }
}

ghost = factory_movie("Ghost in the shell");
matrix = factory_movie("Matrix");
alert(ghost.get_title());
alert(matrix.get_title());
ghost.set_title(1);
ghost.set_title("공각기동대");
alert(ghost.get_title());
alert(matrix.get_title());

var arr = [];
for (var i = 0; i < 5; i++) {
  arr[i] = (function(id) {
    return function() {
      return id;
    }
  }(i));
}

console.log(index); // 여기서 4가 출력되는 이유는?
				// + let을 사용하면 할당 전까진 접근할 수 없는 것이 아닌가?
				// + Hoist시 최종 마지막 결과값으로 인식?

for (let index in arr) {
  console.log(arr[index]());
}


for(var i = 0; i < 5; i++) {
	(function(j) {
		setTimeout(function() { console.log(j); }, j * 100);
	})(i);
}
```

Arguments
함수를 호출할 때 입력한 인자를 가지고 있는 유사배열(배열은 아니다)

함수명.length 정의된 매개변수의 개수, arguments.length 호출시 넘겨준 인자의 개수

둘을 비교해서 의도한 방식대로 작동하도록 사용자에게 알려줄 수 있을 것


자바스크립트에서 함수는 일종의 객체
객체는 속성을 가진다
값이 저장되어있으면 속성이자 프로퍼티
함수가 저장되어있으면 메소드

함수가 정의되면 기본적으로 내장된 메소드 중 하나가 .call, .apply
같은 취지이지만 사용방법이 다름

내장된 코드의 경우에는 네이티브 코드라고만 나옴

두 번째 인자로 원래 넘겨주려던 인자들을 패킹해서 배열로 넘겨줄 것

Apply는 첫 번째 null 인자 대신에 다른 인자를 넘겨줄 때 사용

함수의 정의 자체로는 this가 무엇인지 결정되지 않는다

Apply의 첫 번째 인자로 넘겨준 것이 this가 된다

sum.apply(o1) 을 하는 그 순간에는 => o1.sum

객체 안에 함수를 담을 때는 함수명만 넣을 것





객체지향프로그래밍(OOP) : 로직을 상태와 행동(변수와 메소드)로 나누고 연관된 것들끼리 그룹핑한 것을 객체라 하고 이를 조립해 프로그래밍을 하는 것.

- 객체지향의 여러 가지 특성들 
- 부품화 : 프로그램의 로직들을 기능별로 나눠 부품화하는 것
- 은닉화, 캡슐화 : 로직을 온전히 부품화하기 위해 내부동작법은 숨기고 사용법만 노출하는 것
- 인터페이스 : 부품들간의 접점에서의 규칙, 약속
- 객체지향은 코드의 재활용성을 높인다.



지금까지는 절차지향


객체지향이 철학적인 개념이 내포되어있는 것은 맞지만, 공학 또는 기술의 대상, 문법적 쓰임, 어떻게 만들고 사용하는 것인가에 집중해보자, 너무 추상적으로 받아들이지 말자

상태와 행위로 이루어져있다는 표현도 너무 추상적이어서 좋지 않을 수 있음, 최대한 구체적으로 생각해보자

사이트의 규모가 커지고, 참여자가 늘어나고, 데이터가 많아지면 로직이 점점 복잡해져서 기능별로 그룹핑하고 싶어진다, 기능적으로 로직들을 구분해서 연관되어있는 것들끼리 묶는 그룹핑, 카테고라이즈를 위해 모색된 방법 중 하나가 객체지향

객체 안에 프로퍼티(상태)와 메소드(행위)

구획화를 위해서 객체를 나타내는 문법이 생기고, 하나의 객체 안에는 그 객체의 취지 또는 기능에 연관된 변수와 메소드가 담기고, 재활용성이 높아지지만 그 과정에서 생긴 문제들을 방지하기 위해 여러 가지 문법들이 추가로 생기게 됨

객체지향을 위해서는 설계 방법과 문법을 알아야 한다

현실의 복잡함 중에 우리가 사용하고자 하는 관심사에만 추출하는 것을 추상화라고 한다

복잡한 현실의 추상화가 소프트웨어의 과정

좋은 설계는 지혜의 영역, 지식은 전달되기 쉽지만, 지혜는 그렇지 않다

지혜는 나중에, 우선 지식부터 익히자, 우선 문법과 동작을 익히자

시대에 따라서 부품화의 관점이 바뀐다, 정답은 없고 지금 맥락에서의 적합한 설계가 무엇인지 생각해보자

중복된 로직을 메소드화하듯, 중복된 상태와 행위를 객체화

메소드를 만들면 코드량이 줄어들고, 메소드 별로 기능이 분류되어있기 때문에 유지보수가 쉬워진다, 해당 메소드만 수정하면 사용되는 모든 곳에서도 수정됨

위의 메소드화의 한 단계 위가 객체지향이라고 생각해보자

소프트웨어의 아주 중요한 발전방향 중 하나는 연관되어있는 것끼리 묶고, 그렇지 않은 것과 나누는 것

그룹핑을 했다고 해서 부품화가 달성된 것은 아니다

제대로 된 부품이라면 사용법만 알면 쓸 수 있어야 한다, 내부의 동작 방법을 객체 안으로 숨기고, 사용자에게는 그 부품의 사용방법만을 노출하는 것을 캡슐화라고 한다, 따라서 사용자에게는 사용방법이 중요한 것이 됨

잘 만들어진 부품이라면 부품을 교체할 수 있어야 한다, 부품간의 연결점을 인터페이스라고 한다 (HDMI 케이블)

소프트웨어가 하드웨어가 크게 다르지 않은 부분도 많다, 하지만 부품화라는 비유는 비유일 뿐이다, 비유는 의도한 유사점 뿐만 아니라 의도하지 않은 차이점까지도 전달될 가능성이 있다, 소프트웨어는 하드웨어와 엄연히 다르다, 그 중 하나가 복제와 상속이다, 하드웨어가 기존에 이룩한 성취를 소프트웨어에 잘 수용하면서도 소프트웨어만의 해결방법을 잘 활용해서 제작하는 것이 우리의 숙제



자바스크립트에서는 객체를 만들 때 함수를 이용한다.
함수()에 new라는 단어를 붙이면 객체가 리턴되고 객체를 생성한 함수를 생성자라 한다.
생성자에다가 객체에서 쓸 프로퍼티, 메소드등을 정의하면 코드의 재사용성을 높일 수 있는데 이러한 작업을
초기화라 한다.



JS는 독특한 성격의 객체지향 구현방식을 가지고 있다
prototype-based programming

객체지향 문법을 가지고 있으면서도 함수형 언어의 특징을 가진 언어, 갈수록 미궁인 언어, 대단히 자유롭고  유연함

엉성하고 혼란스러운 부분이 많을 수 있지만 호의를 가지고 바라보면 언어에 대한 이해가 넓어질 수 있을 것

객체에 담긴 변수를 프로퍼티, 그 변수에 담긴 것이 함수라면 메소드

객체간 중복을 방지하기 위해 필요한 것이 생성자, new

자바스크립트를 이해하는 것의 핵심은 객체 이전에 함수

new Person(); 하면 함수가 아닌 생성자이고, 객체를 만들어낸다, 생성자 자체는 소속없이 함수일 뿐, 자바스크립트에서는 클래스가 존재하지 않는다



생성자를 통해 객체에 대한 초기화(Init)를 할 수 있다

```javascript
var person = {
  name: "egoing",
  introduce: function() {
    return "My name is " + this.name;
  }
}

function Person(name) {
  this.name = name;
  this.introduce = function() {
    return "My name is " + this.name;
  }
}

var p1 = new Person("egoing");
document.write(p1.introduce() + "<br />");
```





자바스크립트에서 모든 변수, 함수는 window라는 객체의 프로퍼티, 메소드인데 이 객체를 전역객체라 한다.
전역객체는 암시적으로 모든 변수, 함수에 쓰이므로 생략이 가능하다.



모든 객체는 전역객체의 프로퍼티이다

`window.func();` .앞은 객체, .뒤는 속성

`func();` window는 암시적으로 사용됨

객체라는 것에 모든 것이 소속되어있기에 객체지향 언어

전역객체가 웹 브라우저에서는 window, Node에서는 global





this는 여러 맥락에서 다른 의미로 쓰이지만 하나의 원리는 함수 내에서 함수를 감싸는 함수가 소속된 객체를
의미한다는 것이다.
이런 점을 봤을 때 자바스크립트는 매우 유연하지만 때론 혼란스러운 언어이다.



this는 함수 내에서의 함수 호출 맥락을 의미, 의미가 고정되어있지 않고 상황에 따라서 가변적이다, 함수 안에서 약속되어있는 변수



`window.func();` 함수를 호출했을 때는 전역객체

`o.func();` 메소드를 호출했을 때는 해당 객체



```javascript
var funcThis = null;

function Func() {
  funcThis = this;
}

var o1 = Func();
if (funcThis === window) {
  console.log("window </br>");
}

var o2 = new Func();
if (funcThis === o2) {
  console.log("o2 </br>");
}
```



생성자를 사용하면 해당 함수의 내용에 따른 생성이 끝난 후에 객체로서 변수에 할당해준다

이 과정에서 변수는 아직 초기화되지 않았기 때문에 undefined, 아직 객체에 대한 초기화가 끝나기 전에 해당 객체를 참고할 수 있는 키워드가 this인 것

생성자 안에서의 this는 해당 생성자가 생성하는 객체



함수는 객체

```javascript
function sum(x, y) { return x + y; }
sum(1, 2);

var sum2 = new Function("x", "y", "return x + y;"); // 마지막의 인자가 함수의 본문이 된다

// 생성자를 쓰는 것보다 간편하게 만들 수 있도록 해주는 방식을 리터럴이라고 함, 우측에 있는 값을 왼쪽에 할당
```



if - switch의 관계는, for - while과 비슷



일반적인 객체지향언어에서는 메소드는 객체에 속해있는 것이지만, 자바스크립트에서의 함수는 객체이며 다른 객체들과 동등하다

func(); 할 때는 window에 속해있지만,
func.apply(o); 라고 하면 o에 속해있는 메소드가 되고,
func.apply(p); 라고 하면 p에 속한 func가 된다

호출방식에 따라 this가 달라지는 이유는 소속된 객체의 차이

자바스크립트에서의 함수는 다른 언어의 메소드보다 훨씬 위상이 높지만, 동시에 함수는 어느 객체(window 또는 다른 객체)에 속해있기도 하다

this는 자신이 소속된 객체를 의미한다는 것이 본질

원리를 이해하면 암기를 훨씬 덜할 수 있다



자바스크립트 객체는 자신을 생성한 생성자 함수의 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정함, 객체 리터럴 방식에서는 객체 생성자 함수는 Object(), 생성자 함수 방식의 경우는 생성자 함수 자체

new를 붙여서 호출하면 생성자 함수로 동작



상속 : 부모의 기능을 자식이 물려받는 것.

- 코드의 중복이 줄어든다.
- 상속법 : 자식객체.prototype = new 부모객체(); / 부모객체에서 프로퍼티들 정의할 때 prototype 붙여줌
- 기능추가 역시 자식객체를 생성하고 prototype을 붙여서 프로퍼티를 정의함.



객체는 자기 자신의 맥락에 맞게 부모 객체의 변수와 메소드를 상속받거나 제외할 수 있다, 로직을 재활용할 수 있다

객체를 생성할 때 기본적으로 가지고 있어야 할 프로퍼티를 정의하는 방법이 생성자 외에도 prototype이 있다



```javascript
function Person(name){
    this.name = name;
    this.introduce = function(){
        return 'My name is '+this.name; 
    }   
}
var p1 = new Person('egoing');
document.write(p1.introduce()+"<br />");

// 위와 동일하지만, 상속을 하기 위한 코드
function Person(name){
    this.name = name;
}
Person.prototype.name=null;
Person.prototype.introduce = function(){
    return 'My name is '+this.name; 
}
var p1 = new Person('egoing');
document.write(p1.introduce()+"<br />");

function Programmer(name) {
  this.name = name;
}
Programmer.prototype = new Person(); // prototype이라는 특수한 프로퍼티에 부모 객체를 넘겨줌

var p1 = new Programmer("egoing");
document.write(p1.introduce()+"<br />");
```



객체가 생성자 함수를 통해 생성될 때, prototype이라는 프로퍼티를 생성자 함수가 가지고 있는지 확인하여, 그것의 결과인 객체와 똑같은 객체를 생성해서 생성자 함수의 결과로 리턴해준다. 생성하기 전에 객체의 프로토타입에 원하는 프로퍼티와 메소드를 정의해놓으면 그것들도 함께 프로토타입 프로퍼티에 담겨서 전달될 것.

어떤 객체를 상속받고 싶다면, 그 객체를 생성자 함수의 프로토타입 프로퍼티에 할당시키면 된다

우선 사용법부터 익히고, 원리를 차차 익혀나가면 된다

실수는 우리에게 교훈이 됩니다



부모 객체의 프로토타입을 수정하면, 자식 객체들도 모두 변경된다





자바스크립트는 prototype을 통해서 상속을 제공한다.
객체의 변수, 함수에 대한 정보를 prototype이라는 속성에 저장하는데 그것은 객체 형태로 저장된다.
상속에서 부모 객체의 복제본을 만들어 그것을 상속하고 그것을 통해서 자식 객체의 내용을 바꾸면 부모와 자식간 내용이 달라진다. 라고 생각하면 될 것 같다.

```
음.. 상속이라는 기술이 나타나게 된 기원에 대해 설명을 드려야 할 것 같은데요.
상속이라는 것은 근본적으로, 한번 만들어 놓은 기능을 다시 구현하지 않겠다는 의지의 표현입니다.
한번 만들어 놓은 기능, 즉 코드를 다시 재사용 할 수 있는 가장 쉬운 방법이 무엇일까요?

바로 코드 복사 입니다.
1) A 라는 기능을 만들었는데 거기에 B 라는 기능을 추가하고 싶다면.
2) A 코드를 복사해서, 거기에 B 기능 코드를 추가해 넣으면 됩니다.

그런데, 이렇게 하면 B의 원시(소스)코드안에 A 코드가 중복되게 나타납니다. 이렇게 될 경우 나타나는 문제가

1) 우리가 필요한 B 기능 외에 이미 존재하는 A 의 기능을 표현하기 위한 코드가 중복으로 들어가므로 코드 자체의 용량 증가.

2) 나중에 A 코드 로직이 바뀌어서 수정해야 한다면, B 코드 안의 A 코드까지 수정해야 하는 문제. 만일, B 외에도 C, D, E 도 필요해 각자 A 코드를 복사해 가지고 있다면 이들을 모두 깔끔히 수정해야 하는 엄청난 문제 발생. 

등의 코드를 유지보수 하는데 많은 이슈가 생깁니다.

그리하여, 사람들이 생각한 방법은.. '코드 복사를 인간에 맞기지 말고 언어 레벨에서 지원하도록 하자' 입니다.
근본적으로 B 안에 A의 기능이 구현되려면, 코드 복사외에는 답이 없습니다만 이것을 사람들이 자의적으로 실제 원시(소스)코드 복사를 통해 이루던 것을, 컴퓨터에게 원본 파일이 있는 곳을 알려주고, 실제 실행될때 원본 코드를 복사해와서 내가 추가 구현한 B 기능 위에 복사해 넣도록 한것입니다. 

이것이 저희가 이해하기 쉽게 상속이라고 표현하는 기술의 내부 구현 컨셉입니다. 
컴퓨터는 스스로 (아직?) 생각 못하기 때문에, 사용자가 사용할 부모 기능의 범위등을 알수가 없습니다. 그리고 위에 설명했듯 기원 자체가 코드를 몽땅 복사(또는참조)해 오는 것이기 때문에(사용자가 필요한 것만 골라서 복사하기 보다는, 몽땅 복사하는것이 구현측면에서 훨씬 쉬우리라는것은 쉽게 이해가실겁니다).. 부모 기능 중 사용하기 원하지 않는 기능은 상속 받은 측에서 사용하지 않는 것으로 처리하면 되는 모습으로 최종 안착하게 된 것입니다.

자바 스크립트가 스크립트 언어라서 큰 자유도를 제공한다고 알고는 있는데 상속까지도 골라서 받을수 있게 되어 있을지는.. 개인적으로 의문이긴합니다. 어쨋든 본 글이 상속이라는 것에 대해 이해하는데 도움이 되었으면 좋겠습니다.

PS 밑에 Prototype 섹션을 보고 오니까.. 자바스크립트는 Prototype 이라는 예약 객체에 대한 대입을 통해 상속을 표현한거 같네요..
```





자바스크립트는 prototype을 통해서 상속을 제공한다.
객체의 변수, 함수에 대한 정보를 prototype이라는 속성에 저장하는데 그것은 객체 형태로 저장된다.
상속에서 부모 객체의 복제본을 만들어 그것을 상속하고 그것을 통해서 자식 객체의 내용을 바꾸면 부모와 자식간 내용이 달라진다. 라고 생각하면 될 것 같다.



변수방or객체 = new 함수명();
좌항안에 우항 함수의 코드값을 복사해온다, 로 이해하면 모든 상황에서 일관되게 이해할수있어요.



함수정의시 prototype 객체가 생성되고 생성자 함수와 상호링크하고,
new 생성자로 개별객체 생성시 프로토타입 객체와 내재적 링크로 연결된다



함수를 호출할 때, New를 붙여주면 생성자 함수가 되고, 그 생성자 함수는 새로운 객체를 리턴한다

객체를 만들 때, 그 객체가 가지고 있어야 하는 프로퍼티와 메소드를 기본적으로 가지길 원할 때 생성자 함수를 사용한다

객체가 어떤 프로퍼티와 메소드를 가지고 있는지 가지고 있는 원형이 프로토타입이라는 프로퍼티이다, 프로퍼티 안에는 어떠한 객체가 담겨져있다

new Super()는 Super.prototype이다





우리는 JS로부터 API를 제공받아 만든 결과물을 사용자에게 UI로 제공함

JS + Host환경이 제공하는 표준 내장 객체로 표준 내장 객체의 확장과 사용자 정의 객체 제작

예제 자체는 설명하고자 하는 대상만 포함되는 것을 선호한다, 실용적인 예제는 그것 자체의 복잡성이 높아지기 때문에, 다만 실용적이지 않은 예제는 왜 이 기능을 쓰는지에 대해 전달하기가 어려울 수도 있다



```javascript
var arr = new Array('Seoul', 'New York', 'Ladarkh', 'Pusan', 'Tsukuba');
function getRandomValueFromArray(arr) {
  var index = Math.floor(Math.random() * arr.length);
  return arr[index];
}
console.log(getRandomValueFromArray(arr));
```



표준 내장 객체 : 자바스크립트가 기본적으로 제공하는 객체.

- 표준 내장 객체에 우리가 필요로 하는 기능이 없을 수도 있다. 그럴 때 그 함수를 직접 만들 수도 있지만
  객체에 메소드로 확장시키는 방법도 있다.
- 객체.prototype.메소드이름 = function() {}하게 되면 그 객체의 prototype에 메소드가 추가되면서 객체를 사용
  할 때도 메소드를 사용할 수 있게 된다.

[this란?]
"함수에서의 this는 그 함수가 속한 객체를 가리킨다." (웹브라우저라면 전역객체인 window를 nodejs면 global 이겠지요)
"생성자를 통해 만들어진 객체에서의 this 는 그 만들어진 객체 자신을 가리킨다."
"해당 메서드에 연결된 객체를 가리킨다" - (여기서 이 말이 적용됩니다.)





현상들만 기억하려고 하면 외워야 할 것이 많아진다

암기는 뇌를 혹사시키기에 공부가 지루하게 느껴지도록 하는 원인이 된다

이해를 하고 그 흐름 내에서 현상을 해석할 수 있으면 베스트



object access operator로 접근할 때 wrapper 객체가 원시 데이터 타입을 감싸서 조작할 수 있게 됨



Object.prototype은 모든 객체들의 원형이 됨, 동시에 모든 객체가 가지고 있는 공통 기능

Object.keys와 Object.prototype.toString는 정의 차이로 인해 사용 방법이 달라진다

- Object.keys(객체), Object에만 속해있는 메소드 호출
- 객체.toString

Object.prototype.~ 메소드들은 모든 객체들이 내장하고 있는 메소드이다



코딩을 하기 전에, 내가 만든 것이 어떻게 사용될지를 디자인해보고 시작할 것
기능의 원리적인 의미보다는 어떻게 사용되고 어떤 취지의 기능인지를 알아보려고 할 것





Object : 모든 객체가 상속하는 조상 객체.

- object가 가진 메소드는 두가지 형태가 있다. Object.메소드이름()과 Object.prototype.메소드이름()인데 첫 번째
  형태는 Object 자신만 쓸 수 있고 두 번째 형태는 모든 객체가 쓸 수 있는데 그 이유는 모든 객체가 Object를
  상속하기 때문이다.
- 역으로 Object의 prototype을 이용해서 메소드를 만들면 모든 객체가 쓸 수 있는 강력한 메소드를 만들 수 
  있지만 그만큼 위험해서 의도하지 않은 결과를 초래할 수 있기 때문에 되도록 권장하진 않는다.

Object 객체는 객체의 가장 기본적인 형태를 가지고 있는 객체이다. 다시 말해서 아무것도 상속받지 않는 순수한 객체다.
어떻게 사용될 것인가를 먼저 설계한 후에 구현한다.
기능을 볼 때 기능의 원리적인 것보다 기능이 어떻게 사용되고 어떤 취지의 기능인지 먼저 보고 기능이 어떻게 구현되었는지 본다.



Object.keys()는 클래스 매서드이고 toString은 Object클래스에서 객체를 통해 접근가능한 일반 매서드라고 이해하면 되죠.



Object.모모는 Object라는 함수객체에 있는 메소드들이고
Object.prototype.하하는 루트객체인 Object.prototype에 있는 메소드라서
모든 객체가 다 상속하므로 바로 aObj.하하처럼 객체.하하의 형식으로 사용가능함.
위의 것은 별도의 함수처럼 Object.모모(~)식으로 일반함수 쓰듯이 써야 됨.

실제 스크립트상에서 Object라고 코딩시는 생성자 함수라는 걸 유념.
객체를 생성하는 역할을 하는 생성자 함수객체이고(객체생성시 new Object(); 떠올리면 됨)
거기에 쓸만한 메소드들을 멤버함수로 달아놨다는 식으로 생각하면 됨.

개념설명시 근원이 되는 객체로 Object와 Object.prototype라는 걸 같이 혼용해서 쓰는데
이때문에 많은 사람들이 실제 코드작성시에 Objcet라는 게 생성자 함수객체인데
근원객체로 오인하면서 헷갈려함.
정확히 근원객체, 모태객체의 의미로 사용하는 경우 Object.prototype라고 하는게 매우 정확하고 깔끔한 표현.



작업의 순서, 대상은 무엇인가? 어떤 작업을 할 것인가?