프로그래밍은 도구를 만드는 일이기 때문에, 만드는 과정에서 어느 도구와 함께 할지 선택하는 것도 매우 중요한 문제

신경을 써서 계속 개선시키지 않으면 쓰던 도구만 쓸 수 밖에 없다

인지의 한계를 도구를 통해 극복하는 것

좋은 코드를 작성하려는 노력만큼 좋은 도구를 찾는 노력을 게을리 해서는 안 된다

생산성이 좋은 도구들은 도구의 효용이 좋을수록 사용하기 위해서 충분한 리소스를 가지고 접근해야 지치지 않고 익힐 수 있을 것

지식이라는 것이 순서대로 전달되긴 하지만, 꼭 그 순서대로만 익힐 수 있는 것은 전혀 아니다

현재 다루는 내용이 모르는 것과 함께 나오더라도, 일단 학습 목적에만 집중하는 것이 중요하다

(애매한 것에 관대한 사람과 엄격한 사람, 초반에는 관대한 사람(학습량과 속도)이 후반에는 엄격한 사람(원리와 구조 이해)이 유리하기 마련)

프로그래밍을 할 때 매우 중요한 부분은 변할 수 있는 부분과 변하지 않는 부분을 분리시키는 것이다

좋은 주석을 가지고 있는 코드가 좋은 코드이다(주석조차 필요하지 않고 가독성이 높으면 최고의 코드)

주석은 타인 또는 곧 타인이 될 나 자신을 위해 필요하다

에러는 내가 작성하고 있는 시점에 파악하는 것이 최선이다

본질을 파악하면 이해력도 높아지고 암기할 것도 줄어든다

조건문은 컴퓨터를 똑똑하게, 반복문은 컴퓨터를 강력하게-

기능에 대해서 공부할 때는 그냥 공부하는 것이 아니라, 그것이 없었다면 얼마나 불편할지를 생각해보자

처음 그 기능을 마주한 사람은 얼마나 즐거웠을까? 를 생각해보면 재밌게 할 수 있다

복사 붙여넣기는 전자화된 기기의 최대 혜택중 하나인 듯

감수성이 중요합니다

영어나 수학 때문에 프로그래밍을 못 한다는 생각보다는 프로그래밍을 통해 영어와 수학도 잘 할 수 있게 된다고 생각해보자

---

자바스크립트에서는 정수 실수 구분이 큰 의미가 없음, 프로그래머가 지정한 그대로 형식이 결정되기 때문

수학 관련한 것을 할 때는 Math의 메소드를 사용

Math.random(); 의 결과는 0부터 1 사이의 숫자

Math.round(100 * Math.random());



##### 임지호님 댓글

javascript의 데이터형식에는 크게 숫자와 문자가 있다.
숫자는 또 크게 정수와 실수로 나뉘고 숫자끼리는 사칙연산이 가능하다(+,*,/,-)
사칙연산 뿐 아니라 Math같은 함수를 쓰면 제곱, 제곱근, 난수 등 복잡한 계산도 가능하다.
문자는 ""나 ''사이에 기록되어야 한다.
간혹 ''사이에 '를 써야 하는 경우 \' 이와 같은 모습으로 기록을 해주어야 컴퓨터가 문자로서 '를 인지한다.
\를 이스케이프라 한다.
숫자도 ""나 ''사이에 기록되면 문자로 인식된다.
문자들을 결합하면 결합한 문자들이 이어서 나온다.
문자를 여러줄 쓰고 싶으면 \n이라고 쓰면 된다.(Enter와 같은 역할)
문자에서도 .length나 .indexof같은 명령을 쓰면 여러 가지 복잡한 기능을 수행할 수 있다.



#### 임지호님 댓글

변수 : 값을 담는 그릇(값을 유지할 필요가 있을 때)
var로 시작해서 변수 선언.
다른 값을 담을 수도 있다. 그럴 때는 다시 var 쓸 필요 없다.
변수에는 숫자, 문자 등등 어떤 것도 담길 수 있다.
그것들을 사용해서 연산, 결합 등 할 수 있다
변수 2개를 동시에 선언할 때는 var a = 1, b = 2의 형태로 var는 한 번만 쓰고 ,로 연결하면 된다.
변수는 코드의 재활용성을 높이기 위해서 쓴다.
이것은 코딩을 할 때 대단히 중요한 특성이다.

주석처리 된 코드는 브라우저가 그 코드를 무시해버린다.
//(한 줄)와 /* ~ */(여러 줄)의 형태가 있다.
코드에 대한 설명이 필요할 때 주석을 쓰기도 하고
일시적으로 어떤 코드의 동작을 멈출 때 주석을 쓰기도 한다.

; 명령이 끝났다는 것을 명시적으로 표시

비교 연산자 : 좌항, 우항을 비교할 때 쓰는 연산자

대입 연산자(=) : 우항의 값을 좌항에 대입할 때 사용
동등 연산자(==) : 좌항, 우항의 값이 같으면 true, 다르면 false(실질적인 정보의 값을 비교)
일치 연산자(===) : 위와 내용은 같음(데이터 형식까지 엄격하게 비교, 동등보다는 이것을 쓰는 것을 권장)
undefined : 프로그래머가 의도하지 않은 값 없는 상태, null : 의도한 값 없는 상태

조건문은 조건에 따라 실행을 달리 하게 하는 것이다.
if(true) {...} 실행한다. if(false) {...} 실행 안한다.
if(true) {...} else {~~~} true이면 ... 실행하고 false이면 ~~~실행한다.
else if로 조건문을 더 풍성하게 할 수 있다. 수많은 else if 중 true인것만 실행하고 없다면 else 실행한다.
(else는 생략 가능하다)
조건문은 중첩 또한 가능하다.
논리 연산자 
-&&(AND) : 좌항, 우항 모두 true일 때 전체가 true
-||(OR) : 좌항, 우항 중 하나만 true이면 전체가 true
-!(NOT) : true이면 false로, false이면 true로 변환

반복문 : 코드를 반복적으로 실행하게 하는 기술.
while과 for문이 있다.
while(반복조건) {실행코드} 이런 문법적 형태를 띄는데 무한루프에 빠지지 않도록 하는 초기화변수와 변수를 증가시키는 코드, 반복조건 코드가 필요하다.
이것을 한눈에 보기 좋게 표현한 것이 for문이다.
for(var i=0; i<10; i++) {실행코드}의 형태를 띈다. 반복문은 반복문끼리 그리고 조건문과도 중첩이 가능하다.

* i++과 ++i의 차이 : i++은 i를 실행하고 i에 1을 더하고 ++i는 1을 더하고 i를 실행한다.

document.write : 웹페이지에 텍스트를 출력

함수 : 코드의 재사용성을 높이기 위한 기술.
function 이름 (매개변수) {실행코드}의 형태를 가진다.
실행할때는 이름(인자)를 하면 실행코드에서 return값이 출력된다.
반복문과 같이 반복할 수 있다는 특성이 있지만 반복문은 단순반복이고 함수는 입력값에 따라 출력값이 다르게
반복되고 여러군데에서 사용할 수 있다.
코드의 재사용성을 높일 수 있고 유지보수가 용이해지며 가독성 또한 좋아진다.
변수이름 = function(매개변수) {실행코드}의 형태로도 함수를 정의할 수 있고
(function(매개변수) {실행코드})(); 이런식의 형태는 익명함수로 함수를 정의하고 바로 호출해야할 때 사용한다.
함수기능은 반복화의 중요한 부분을 기능으로 만드는 작업
과도한 함수화는 소스 가독성을 느리게 한다는 점을 명심하기
반복문은 그 자리에서 바로 반복을 하게끔 하는 효용이 있는 반면, 함수는 반복적으로 실행되는 로직이 다양한 맥락에서 호출되어야 할 때 아주 유의미하다
사용하는 입장에서는 이름과 그것의 역할과 영향만 알면 사용할 수 있다
즉 함수는 재사용성, 유지보수의 용이, 가독성이라는 프로그래밍이 지향하는 바와 밀접하게 연관되어있다
함수의 함은 상자, 인풋을 넣으면 아웃풋이 나오는 상자의 의미
함수의 입력과 출력에서 출력은 return이 담당하는 역할, 입력은 argument가 담당
또한 입력되는 인자는 argument, argument(함수 호출시)를 받는 자리는 parameter(함수 안)
입력은 여러 개를 동시에 받을 수 있으나, 출력은 오직 한 번만 가능(이 출력은 console.log의 출력과는 다르다)
함수를 선언하고 그것을 ()로 감싸면서 그 안에 ()를 넣어서 바로 호출할 수 있다 = 익명함수
자바스크립트에서는 함수가 차지하는 위상이 매우 높다



배열 : 여러 개의 데이터를 담기 위한 그릇의 역할

- 하나하나의 데이터를 원소라 하고 그것을 식별하는 식별자를 주로 인덱스라 칭한다.(0부터 순서대로 자동매김)


- 배열.length : 배열의 크기 출력
  .push : 배열 끝에 원소 추가
  .concat : 여러개 원소 추가
  .unshift : 배열 처음에 원소 추가
  .splice : 배열 요소의 추출 또는 추가
  .shift : 첫 번째 원소 제거
  .pop : 맨 뒤 원소 제거
  .sort : 정렬(사용자가 정의한 기준으로도 정렬 가능)
  .reverse : 역순정렬





함수가 한 번에 하나만 반환할 수 있는 한계를 극복하기 아주 좋은 방식이 배열이다
배열의 인덱스별 데이터를 모두 기억할 수는 없으므로, 기본적으로 배열에 담겨진 데이터들을 꺼내어 가공할 때 주로 사용하게 된다(인덱스별 데이터를 기억해서 활용해야 할 때는 객체를 사용해야 할 것)
배열은 반복문과 함께 사용되었을 때 진정한 힘이 나온다
배열.length를 사용하여 배열의 원소 개수와 비례한 반복문을 작성할 수 있음
인자, 반환값, 설명, 예제를 참고하여 레퍼런스로부터 학습하자
정렬은 배열을 사용하는 이유 중 하나이고 프로그래밍에서 상당히 중요한 주제이다
언어에서 지원하는 정렬방법을 사용하는 것이 지금은 가장 효과적일 것
sort function을 지정해서 원하는 방법에 따라 정렬할 수 있다



객체 : 연관된 데이터를 담는 그릇. 인덱스를 문자로 사용하는 것이 배열과 다른 점.

- var .... = {'key값' : value값 , ~~~~}의 형태, 빈 객체 만들고 후에 값 지정도 가능
- 객체와 반복문이 만날 때 for(key in 객체) { ...key - key값 or 객체[key] - value값}(배열에서도 사용 가능)
- 객체 안에 객체 또는 함수가 들어갈 수 있음(연관된 데이터, 처리를 그룹핑해서 프로그래밍하는 것을
  객체지향프로그래밍이라 함)
- 함수 안에서 this를 사용하면 함수를 가지고 있는 객체를 가리키는 변수로 사용된다.




배열은 색인이 자동으로 지정되는 것에 반해, 객체는 우리가 원하는 색인(key)을 할 수 있다
다른 언어에서는 연관배열, 맵, 딕셔너리 등이 객체에 해당한다
객체 지향과 연결되는 부분
데이터를 호출할 때 dot notation으로는 문자열 형태를 받을 수 없으므로 그럴 때는 []를 사용할 것
문자열 또는 변수로 접근해야 한다면 []를 써야만 한다, 아닌 경우에는 dot notation 사용
배열은 순서가 있으나, 객체는 그렇지 않다(오직 key를 통해서 접근)
for in문 활용
값으로서의 함수를 value로 가지고 있을 수 있고, 그 함수의 this는 그 함수를 가지고 있는 객체를 가리킴
연관되어있는 데이터와 함수를 객체로 그룹핑해놓는 것을 객체지향 프로그래밍이라고 함

```javascript
var grades = {
  list: {egoing: 10, k8805: 8, sorialgi: 80},
  show: function() {
    for (let name in this.list) {
      console.log(name, this.list.name);
    }
    console.log(this.list);
  }
}

grades.show();
```





모듈 : 로직들을 부품화한 것. 부품화하는 과정을 모듈화라 함.

- 모듈화하면 유지보수, 재사용성, 비용절약 등 많은 측면에서 이익이 생김.
- 호스트 환경(웹브라우저, node.js, 구글앱스스크립트 등)마다 모듈화하는 방식이 다름(자바스크립트 내부에서 모듈화하는 기능은 없음)
- 웹에서는 <head>태그에 자바스크립트파일을 로드하는 방식을 사용
- 라이브러리도 모듈과 비슷한 느낌이지만 모듈은 부품 하나라면 라이브러리는 방대한 코드의 집합의 느낌



프로그램은 작고 단순한 것에서 크고 복잡한 것으로 진화하는데, 이때 코드의 재활용성과 유지보수의 편이성을 위해 모듈화가 꼭 필요하다
재사용할 수 있는 단위로 구획화시킨 것이 모듈, 그것을 만드는 것이 모듈화
함수보다 더 큰 개념이 모듈(재사용성을 높이기 위한 관점에선 동일)
필요한 함수, 변수, 로직을 묶어 모듈화
필요한 코드와 그렇지 않은 코드를 분리해서 생각해보자
이 파일에서 중요하지 않은 부분을 모듈화해서 분리해내어, 이 파일의 가독성을 획기적으로 높일 수 있다
<script src="greeting.js"></script> 라고 선언하면 greeting.js의 파일 내용들이 >< 사이에 적힌 효과
Node.js에서는 require를 통해 module을 import해온다 (JS 호스트 환경마다 다르다는 예시)라이브러리는 모듈과 비슷한 개념이다. 모듈이 프로그램을 구성하는 작은 부품으로서의 로직을 의미한다면 라이브러리는 자주 사용되는 로직을 재사용하기 편리하도록 잘 정리한 일련의 코드들의 집합을 의미한다고 할 수 있다.
내가 구현하려는 기능이 내 서비스의 핵심에 해당하지 않는다면, 이미 구현되어있는 라이브러리가 있는지 찾아볼 것, 단지 사용하려는 목적이라면 이미 있는 라이브러리보다 품질이 좋기는 어렵다웹과 관련한 어느 JS 라이브러리라도 JS와 브라우저가 제공하지 않는 기능을 할 수는 없다
라이브러리란 어떤 특정 목적을 설정해놓은 로직들의 집합
jQuery를 사용하려면 모듈을 import를 해와야 함, 제공하는 기능들은 Documentaion Doc에 적혀있을 것
라이브러리를 사용하려면 import 방법과 Documentation 숙지하는 것이 핵심
환경을 제어하기 위해선 그 환경이 제공해주는 API가 무엇이 있고, 어떤 특성과 사용법인가를 알아내야 함
자신이 필요한 것을 스스로 찾을 수 있는 것이 주체적인 프로그래밍의 시작점일 것



Interface : 주체와 주체가 만나는 접점

- UI : 사용자와 시스템이 만나는 접점
- API : 시스템과 프로그래머가 만나는 접점(개발자는 시스템, 프로그래밍언어의 API를 통해 프로그램을 제어)
- 프로그래밍을 공부하기 위한 자료 : 튜토리얼(기본적인 조작 안내서(문법)), 레퍼런스(명령어 사전)
- 자바스크립트는 자바스크립트가 기본적으로 제공하는 API와 그것이 구동되는 호스트환경이 제공하는 API가 
  다르다.

튜토리얼을 통해 해당 환경이 어떤 API를 제공해주는지 사전기반을 쌓고 (문법), 레퍼런스를 통해 자세히 익힐 수 있음 (사전)
자바스크립트 API는 자바스크립트 자체의 API와 호스트 환경의 API로 구분된다
프로그래밍이란 API + 커뮤니티나 검색을 통해 문제 상황에 대한 답을 찾아가는 과정일 것



전역변수/지역변수 : 함수 바깥에서 선언된 변수(전역적으로 영향을 미침)/함수 내에서 선언된 변수(함수 내에서만
영향을 미침)

- 전역변수는 거의 쓰이지 않음(프로그램이 커질수록 변수의 이름이 서로 헷갈릴 수 있기 때문. 이런 개념도 그러
  한 문제때문에 고안된 것)
- 함수 밖에서 var를 쓰면 전역변수, 함수 안에서 var를 쓰면 지역변수
- 전역변수를 딱 하나만 쓰려면 전역변수 하나를 객체로 만들고 그 소속 아래 나머지 변수를 선언한다.
- 전역변수를 쓰지 않으려면 만든 로직을 익명함수화한다(모듈화의 기초)
- 자바스크립트의 지역변수는 {}가 아니라 함수!에서만 유효하다.
- 자바스크립트는 정적 유효범위를 채택한다(함수 호출시점이 아니라 선언 시점을 기준으로 한다)


앞선 내용들은 어느 프로그래밍 언어든 제공할 개념들이다
갖게 될 것보다 갖고 있는 것을 더 중요하게 생각하길 바란다
자바스크립트에서의 함수는 모듈화의 근간이다
같은 함수 내에 변수명이 없을 경우, 전역 변수 중에서 해당 변수명에 해당하는 변수가 있는지 찾는다
블록이 아닌 함수 단위의 스코프를 제공한다
왜 전역변수를 써야 하는지 구체적으로 인지하고 있는 상황이 아니라면 늘 지역변수를 사용할 것
수많은 함수와 변수가 만들어질 수 있는데 그것들이 결합되는 과정에서 같은 변수명을 사용해서 겹치게 되면 이름의 충돌으로 인해 예상과 다르게 동작하는 문제가 생길테니 최대한 지역변수를 사용하는 것이 좋다
파일 -> 디렉토리 와 같이 문제를 해결하기 위해 나온 결과물이 스코프
프로그래밍 개념들이 그냥 하늘에서 떨어진 것이 아니라 그 당시의 문제들을 해결하기 위한 고민의 결과라고 생각하고 공부해볼 것
null은 프로그래머가 현재 값을 지정하지 않았다는 것을 명시적으로 선언한 것
같은 이름의 지역변수와 전역변수가 있을 경우 지역변수가 우선한다
불가피하게 전역변수를 사용해야 한다면, 객체에 담아서 사용하자
함수가 선언된 시점에서의 유효범위를 가짐, 이것을 정적 유효범위(lexical scoping)라고 함
사용될 때가 아닌, 정의될 때의 스코프를 가진다, 반대를 동적 유효범위라고 함
프로그래밍이 커지면서, 이해되지 않는 문제들이 생기면 스코프 때문일 가능성이 있다

```
자바스크립트에서 함수를 선언할때
function statement 방식과 function expression 방식이 있는데 
(Function() 생성자 함수를 사용한 방법도 있습니다)

function statement 방식은 흔히 함수를 선언하는

function a()
{
함수식;
}

방식이고

function expression 방식은 변수를 선언해서 함수를 대입하는 방식입니다.

var a = function(){};

이런씩으로 생성이 되는데 여기서 또 함수의 접근 범위가 달라집니다.


a();

function a()
{
alert(1);
}

이런 식으로 함수 선언보다 앞에서 함수를 호출하면 호출이 됩니다.

하지만

a();

var a = function()
{
alert(1);
}
이런 식으로 function expression 방식으로 함수를 선언하게 되면 
함수 호출을 막아줍니다.
그래서 이런 식으로 함수를 선언하라고 권고 하고 있고요

이런 현상은 호이스팅이라고 한다 (선언과 할당의 분리)
```

```javascript
var vscope = 'global';
function fscope() {
  var vscope = 'local'; // 지역변수로 vscope가 생성됨
  vscope = 'local'; // 위에서 생성된 지역변수에 값을 할당하게 됨
}
fscope();
alert(vscope);

// 단 하나의 전역변수도 사용하고 싶지 않을 때
(function() {
  var myAPP = {};
  myAPP.calculator = {
    left: null,
    right: null
  };
  myAPP.coordinate = {
    left: null,
    right: null
  };
  
  myAPP.calculator.left = 10;
  myAPP.calculator.right = 20;
  function sum() {
    return myAPP.calculator.left + myAPP.calculator.right;
  }
}())

var i = 5;

function a() {
  var i = 10;
  b();
}

function b() {
  document.write(i);
}

a();
```

값으로서의 함수 : 자바스크립트에서 함수는 값으로도 쓰일 수 있다(변수에 담기, 객체 안에 저장하기, 다른 함수의 인자로 사용하기, 함수의 리턴값으로 사용하기, 배열의 값으로 사용하기 등) -> first-class-object,citizen이라함
*객체 안에서 key는 변수 역할, 속성이라고도 부르고 value에 함수가 담긴다면 이는 메소드라 부른다
- 콜백함수 : 함수가 다른 함수의 인자로 사용됨으로써 그 함수의 내용을 완전히 바꿀 수 있는 것.
- 비동기처리 : 시간이 오래 걸리는 작업을 나중에 처리해서 일련의 작업을 순서대로 처리하지 않음으로써 사용의 편의성을 높이는 기법.(일반 환경에서는 보이지 않고 서버 환경에서 구동된다) - 대표적으로 Ajax라는 기법이있음


값으로서의 함수와 콜백
함수도 객체, 함수 역시 일종의 값, 함수 자체가 값이 될 수 있다
함수는 값이기에 객체 안에 저장될 수 있다, 객체의 key는 곧 변수와 같은 역할, 이것을 속성이자 프로퍼티라고 함, 이렇게 객체의 속성 값으로 담겨진 함수를 메소드라고 부른다
다른 함수의 인자로 전달될 수 있음, 함수는 함수의 리턴 값으로도 사용할 수 있다
배열의 값으로도 사용할 수 있음, 뒤에 (인자) 를 전달해주면 호출됨
변수, 매개변수, 리턴값으로 활용될 수 있는 데이터를 프로그래밍에서는 일급 객체라고 한다
값으로 사용될 수 있는 특성을 이용하면 함수의 인자로 함수를 전달할 수 있다
값으로 전달된 함수는 호출될 수 있기 때문에 이를 이용하면 함수의 동작을 달리 할 수 있다
numbers.sort(); 가 있을 때 . 앞의 것을 객체라고 함
객체에 속해있는 함수는 메소드
언어에서 기본적으로 정의되어있는 것들을 내장 객체, 내장 메소드, 빌트인 객체 빌트인 메소드라고 한다, 그렇지 않은 것들은 사용자 정의 객체, 사용자 정의 함수라고 한다
sort는 기본적으로 문자열로 정렬하고 윈도우 이름 순서도 이렇다
반환값은 배열, 자기 자신에 대한 레퍼런스값
값으로서의 함수의 특징을 활용하여, 다른 함수의 인자값으로 함수를 전달하는 것을 통해 동작 방식을 바꿀 수 있다, 이때 넘겨주는 함수를 콜백함수라고 함
비동기 방식의 예시로는 To Do List를 떠올리면 된다
Ajax 비동기 자바스크립트 통신방식이 비동기적 처리의 예시, 웹페이지가 변경되지 않고 일부분만 변경할 수 있게 해줌, 웹이 문서에서 벗어나서 동작들을 할 수 있는 애플리케이션으로 발전되는 중요한 계기가 됨
이것을 구현하려고 할 때, 브라우저별로 차이점이 발생하는데, jQuery를 사용하면 쉽게 할 수 있음
정보를 가져오기 위한 Ajax라는 과정 자체는 모두 같지만, 정보를 가져온 다음에 어떤 로직을 작동해야 할지는 콜백함수가 결정하는 것
고난도 테크닉이자, 유지보수를 쉽게 만드는데 중요한 개념이다

```javascript
function cal(mode) {
	var funcs = {
		plus: function(left, right) { return left + right },
		minus: function(left, right) { return left - right }
    };
	return funcs[mode];
}

alert(cal("plus")(2, 1));
```

클로저

클로저 : 내부함수가 외부함수의 맥락에서 접근할 수 있는 것.(함수 안에서만 사용하는 함수를 만들 때 유용)
- 내부함수 : 함수 안에 함수가 선언되 있는 것
- 외부함수 : 내부함수 바깥에 선언된 함수
- 내부함수는 외부함수의 지역변수에 접근할 수 있다.
- 외부함수가 소멸되도 내부함수는 외부함수의 지역변수에 접근할수 있다.
- 프라이빗변수 : 정보를 아무나 수정하는 것을 방지하는 기법(이 기법에 클로저를 사용)

내부함수의 외부함수의 지역변수에 접근할 수 있다
외부함수가 종료된 이후에도 내부함수는 외부함수에 접근할 수 있다
자신들이 실행된 그 시점에서의 외부함수의 지역변수에 접근할 수 있고 그것은 유지되고 있다
그리고 자신이 가지고 있는 맥락의 외부함수 지역변수를 변경해도, 다른 클로저에는 영향을 미치지 않는다
클로저는 자바스크립트가 Private Variable를 사용하게 되면 즉 어떤 데이터에 접근할 수 있는 경로가 제한되면, 그 데이터를 다른 이들이 다른 맥락에서 사용하더라도 영향을 받지 않게 할 수 있고, 그 변수를 수정할 때도 Validation할 수 있고, 읽는 경로도 제한되기 때문에 훨씬 안전하게 저장될 수 있다, Closure는 자바스크립트가 Private한 변수를 만들게 하는데 매우 좋은 매커니즘이다, 클로저를 통해 맥락을 만들어낼 수 있다는 점이 핵심
지역변수에 매개변수도 당연히 포함된다

클로저는 독립적으로 클로저 안에 정의된 함수를 기억하기 위해서 사용합니다.
주의할점은 클로저가 필요하지 않은 작업인데도 함수안에 함수를 만듬으로써
스크립트 처리 속도와 메모리 사용량 모두에 부담을 주므로 유의하여야 합니다.
실용적인 클로저란 "하나의 객체에서 여러가지 이벤트에 반응하는 콜백을 사용하는 상황" 에 매우 적합하다.

```javascript
function factory_movie(title) {
  return {
    get_title: function() {
      return title;
    },
    set_title: function(_title) {
      if (typeof _title === "string") {
        title = _title;
      } else {
        alert("제목은 문자열이어야 합니다.");
      }
    }
  }
}

ghost = factory_movie("Ghost in the shell");
matrix = factory_movie("Matrix");
alert(ghost.get_title());
alert(matrix.get_title());
ghost.set_title(1);
ghost.set_title("공각기동대");
alert(ghost.get_title());
alert(matrix.get_title());

var arr = [];
for (var i = 0; i < 5; i++) {
  arr[i] = (function(id) {
    return function() {
      return id;
    }
  }(i));
}

console.log(index); // 여기서 4가 출력되는 이유는?
				// + let을 사용하면 할당 전까진 접근할 수 없는 것이 아닌가?
				// + Hoist시 최종 마지막 결과값으로 인식?

for (let index in arr) {
  console.log(arr[index]());
}


for(var i = 0; i < 5; i++) {
	(function(j) {
		setTimeout(function() { console.log(j); }, j * 100);
	})(i);
}
```

Arguments
함수를 호출할 때 입력한 인자를 가지고 있는 유사배열(배열은 아니다)
